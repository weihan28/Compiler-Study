![[Screenshot 2024-06-13 at 9.33.38 PM.png]]

- a statement can be a block
- blocks can be nested, several declarations of the same identier can appear within a single block

![[Screenshot 2024-06-13 at 9.35.21 PM.png]]

Most Closely Nested Rule
---
can be implemented by chaining symbol tables. ie: the table for a nested block points to the table for its enclosing block.

![[Screenshot 2024-06-13 at 9.40.37 PM.png]]
![[Screenshot 2024-06-13 at 9.39.19 PM.png]]
**Environment** is represented by a reference to the lowest symbol table - the one for B2.


Environment
---
![[Screenshot 2024-06-13 at 9.45.19 PM.png]]

Class Env supports three operations:
- Create a new symbol table.
	constructor Env(Env prev).
- Put a new entry in the current table.
	![[Screenshot 2024-06-13 at 10.14.50 PM.png]]
- Get an entry for an identifiier by searching the chain of tables, starting with the table for the current block.

Chaining of symbol tables results in a tree structure, since more than one
block can be nested inside an enclosing block.
![[Screenshot 2024-06-13 at 10.01.36 PM.png]]


Class Env implements chained symbol tables:
```java
package symbols;
import java.util.*;

public class Env {
	private Hashtable table;
	protected Env prev;

	public Env(Env p) {
		table = new Hashtable();
		prev = p;
	}

	public void put(String s, Symbol sym) {
		table.put(s, sym);
	}

	public Symbol get(String s) {
		for (Env e = this; e != null; e = e.prev) {
			Symbol found = (Symbol) (e.table.get(s));
			if (found != null ) return found;
		}
		return null;
	}
}

```